
<div class="bracket-component" page-restrict="true" edit-enabled="@(AllowEditing ? "true" : "false")">
	@if (AllowEditing && GroupedMatches.IsNotNull())
	{
		<span>Click on a match to update its information.</span>
		<span>It is not necessary to save the tournament when making Match changes!</span>
	}
	<div class="bracket-component-view" id="tournament-bracket-@Tournament?.Id">
		@if (GroupedMatches.IsNotNull())
		{
			@foreach (var group in GroupedMatches)
			{
				var matches = group.ToList();

				<div class="bracket" round-number="@group.Key">
					<div class="bracket-header">
						<span>Round @group.Key</span>
					</div>
					<div class="bracket-list" round-offset="@(group.Key % 2)" round-number="@group.Key" style="--roundsize: @group.Key">
						@for (int i = 0; i < matches.Count; i++)
						{
							var match = matches[i];

							<div class="round-match" single-team="@(match.Members?.Count() <= 1)" match-winner="@match.Winner">

								@if (match.Members.IsNotNull())
								{
									foreach (var member in match.Members)
									{
										MemberModel model = GetMember(member);
										<a class="@(match.Winner == member ? "winner" : match.Winner != null ? "loser" : string.Empty) tournament-member tournament-@Tournament?.Id-@model.Id" member-id="@model.Id" @onclick="(() => MatchPlayerClicked(match))" onmouseover="highlightMember(@Tournament?.Id, @model.Id)" onmouseleave="unhighlightMember(@Tournament?.Id)">
											<span>@model.Name</span>
										</a>
									}
								}

								@if (matches.Count != 1)
								{
									<div class="exit @GetElevation(i + 1, i + 1 == matches.Count)" single-team="@(match.Members?.Count() <= 1)">
										<div class="entry @GetElevation(i+1, i+1 == matches.Count)"></div>
									</div>
								}

								@if (Debug)
								{
									<div style="z-index: 2; position: absolute; top: -10px; left: 0;">
										<span style="margin-right: 10px">@match.Id</span>
										<span>@match.MatchNumber</span>
									</div>
									<div style="z-index: 2; position: absolute; top: -10px; right: 0;">
										@if (match.ParentMatches.IsNotNull())
										{
											foreach (var item in match.ParentMatches)
											{
												<span style="margin-right: 10px">@item</span>
											}
										}
									</div>
								}
							</div>
						}
					</div>
				</div>
			}
		}
	</div>
</div>

@if (EditVisible)
{
	<div class="page-window-container">

		<div class="page-window-blocker" @onclick="HideMenu"></div>

		<div class="page-window-window">
			<button class="window-close" @onclick="HideMenu">
				<i class="fa-solid fa-x"></i>
			</button>

			<h4>Edit Match</h4>

			<div class="window-value">
				<label>
					Member 1
				</label>
				<InputSelect TValue="int?" @bind-Value="Member1">
					@if (Tournament?.Members != null)
					{
						foreach (MemberModel member in Tournament.Members)
						{
							<option checked="@(Member1 == member.Id)" value="@member.Id">
								@member.Name - @member.Id
							</option>
						}
					}
				</InputSelect>
			</div>

			@if (EditModel?.Members?.Length > 1)
			{
				<div class="window-value">
					<label>
						Member 2
					</label>
					<InputSelect TValue="int?" @bind-Value="Member2">
						@if (Tournament?.Members != null)
						{
							foreach (MemberModel member in Tournament.Members)
							{
								<option checked="@(Member2 == member.Id)" value="@member.Id">
									@member.Name - @member.Id
								</option>
							}
						}
					</InputSelect>
				</div>
			}

			<div class="window-value">
				<label>
					Winner
				</label>
				@if (EditModel.IsNotNull() && Member1.IsNotNull() && Member2.IsNotNull())
				{
					<InputSelect TValue="int?" @bind-Value="EditModel.Winner">
						<option checked="@(Member2 == null)" value="">
							None
						</option>
						@if (Tournament?.Members != null)
						{
							var mem1 = Tournament?.Members.FirstOrDefault(x => x.Id == Member1);
							var mem2 = Tournament?.Members.FirstOrDefault(x => x.Id == Member2);

							if (mem1.IsNotNull())
							{
								<option checked="@(Member1 == EditModel.Winner)" value="@Member1">
									@mem1?.Name - @mem1?.Id
								</option>
							}
							if (mem1.IsNotNull())
							{
								<option checked="@(Member2 == EditModel.Winner)" value="@Member2">
									@mem2?.Name - @mem2?.Id
								</option>
							}
						}
					</InputSelect>
				}
			</div>

			<button @onclick="UpdateMatch" disabled="@CheckMembers">
				Update
			</button>
		</div>

	</div>
}

@code {
	private bool Debug = false;

	private bool EditVisible { get; set; }

	[Parameter]
	public AdvancedTournamentModel? Tournament { get; set; }

	[Parameter]
	public bool AllowEditing { get; set; }

	public MatchModel? EditModel { get; set; }
	public int? Member1 { get; set; } = null;
	public int? Member2 { get; set; } = null;
	private bool CheckMembers => !(Member1.IsNotNull() && Member1 != 0 && Member2.IsNotNull() && Member2 != 0 && Member1 != Member2);

	private List<MatchModel>? Matches { get; set; }

	private IEnumerable<IGrouping<int, MatchModel>>? GroupedMatches { get; set; }

	private Dictionary<int, MemberModel>? MemberList = new();


	private string GetElevation(int num, bool overrideCom = false)
	{
		return overrideCom ? "up" : num % 2 == 0 ? "up" : "down";
	}

	private MemberModel GetMember(int? id)
	{
		if (MemberList.IsNotNull() && id.IsNotNull() && MemberList.TryGetValue(id.Value, out MemberModel? value))
		{
			return value;
		}
		return new MemberModel((int)Team.TBD, Team.TBD.ToString(), Team.TBD.ToString());
	}

	protected override void OnInitialized()
	{
		if (Tournament.IsNotNull())
		{
			if (Tournament.Matches.IsNotNull())
			{
				Matches = Tournament.Matches;
			}

			MemberList = Tournament.Members?.ToDictionary(x => x.Id);

			// Add missing 1 round matches
			FillExpectedMatches();
		}

		if (Matches.IsNotNull())
		{
			CheckNext(Matches, 1);

			GroupedMatches = Matches.Where(x => x.Round != null).OrderBy(x => x.Round).OrderBy(x => x.MatchNumber).GroupBy(x => x.Round ?? -1);
		}

		base.OnInitialized();
	}

	private void FillExpectedMatches()
	{
		int firstRound = 1;

		if (MemberList.IsNotNull() && MemberList.Count > 0)
		{
			Matches ??= new();

			int checkCount = MemberList.Count;
			// 1  2 & % 4 (Checking to fit correct amount of matches)
			while (checkCount % 8 != 0 && checkCount > 0 && checkCount != 2 && checkCount != 4)
				checkCount--;
			// Will be double the number of matches (2 per match)

			MatchModel? currentMatch = null;

			int matchNumber = 1; // Keeping track of each match
			bool firstcheck = true;
			for (int i = 1; i <= checkCount; i++)
			{
				if (!currentMatch.IsNotNull())
				{
					// Only get Round 1 matches
					currentMatch = Matches.FirstOrDefault(x => x.Round == firstRound && x.MatchNumber == matchNumber);
					// Set it as dummy if no match has been saved
					currentMatch ??= new MatchModel(null, firstRound, matchNumber, [0], null, null, null, Tournament?.Id);
					// Up MatchNumber
					matchNumber++;
				}
				// If match is not null and has less than 2 members
				else if(currentMatch.Members.IsNotNull() && currentMatch.Members.Length < 2)
					currentMatch.Members = currentMatch.Members.Concat([0]).ToArray();

				// if final iteration or if match.member length is more or equal to 2
				if (i == checkCount || !firstcheck)
				{
					// Only add if not a valid (Existing match)
					if (!Matches.Any(x => x.Round == currentMatch.Round && x.MatchNumber == currentMatch.MatchNumber))
						Matches.Add(currentMatch);

					currentMatch = null;
				}

				firstcheck = !firstcheck;
			}
		}
	}

	private void CheckNext(List<MatchModel> matches, int round)
	{
		var currentMatches = matches.Where(x => x.Round == round).OrderBy(x => x.MatchNumber).ToList();

		if (currentMatches.Count <= 1)
			return;

		// Setup values
		int maxNum = currentMatches.Count();
		int nextRound = round + 1;

		// Local values
		int matchNumber = 1;
		int expectedMax = 0;

		int? singleMatch = null;
		if (currentMatches.Count % 2 == 1)
		{
			expectedMax = (maxNum + 1) / 2;
			singleMatch = expectedMax;
		}
		else
			expectedMax = maxNum / 2;

		int currentChecked = 0;
		for (matchNumber += 0; matchNumber <= expectedMax; matchNumber++)
		{
			var nextMatch = matches.FirstOrDefault(x => x.Round == nextRound && x.MatchNumber == matchNumber);
			if (nextMatch.IsNotNull())
			{
				nextMatch.Members ??= [];
				int memberCount = singleMatch != nextMatch.MatchNumber ? 2 : 1;
				// Make sure that the correct amount of "members" is present
				while (nextMatch.Members.Length < memberCount)
				{
					nextMatch.Members = nextMatch.Members.Concat([0]).ToArray();
				}
			}
			else
			{
				var num1 = currentMatches.ElementAtOrDefault(currentChecked)?.Id;
				var num2 = currentMatches.ElementAtOrDefault(currentChecked + 1)?.Id;
				List<int> parents = new();
				if (num1 != null)
					parents.Add(num1.Value);
				if (num2 != null)
					parents.Add(num2.Value);

				// Set dummy match with TBD value for teams
				nextMatch ??= new MatchModel(null, nextRound, matchNumber, singleMatch == matchNumber ? [0] : [0, 0], parents.ToArray(), null, null, Tournament?.Id);
				// Add dummy match (Based on invalid Id of 0)

				matches.Add(nextMatch);
			}
			currentChecked += 2;
		}

		matchNumber--;

		CheckNext(matches, nextRound);
	}

	public void HideMenu()
	{
		EditModel = null;
		Member1 = null;
		Member2 = null;
		EditVisible = false;
		StateHasChanged();
	}

	private void MatchPlayerClicked(MatchModel model)
	{
		if (AllowEditing)
		{
			EditModel = model;

			Member1 = EditModel.Members?.ElementAtOrDefault(0);
			Member2 = EditModel.Members?.ElementAtOrDefault(1);

			EditVisible = true;
			StateHasChanged();
		}
	}
	private async Task UpdateMatch()
	{
		if (EditModel.IsNotNull())
		{
			List<int> members = new();
			if (Member1 != null)
				members.Add(Member1.Value);
			if (Member2 != null)
				members.Add(Member2.Value);

			// Only allow for setting 2 members
			if (!Member1.IsNotNull() || !Member2.IsNotNull())
				return;

			if (Member1 == Member2)
				return;

			EditModel.Tournament ??= Tournament?.Id;

			if (!EditModel.Tournament.IsNotNull())
				throw new ArgumentNullException("Match is missing TournamentId");

			EditModel.Members = members.ToArray();

			var updated = await GameService.PutMatch(EditModel);
			if (updated)
			{
				HideMenu();
			}
		}
	}
}
